import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { RefreshCcw, Dice6, RotateCcw, Home, X } from 'lucide-react';

// --- CONFIGURATION CONSTANTS ---
const NUM_PLAYERS = 4; // Default number of players
const TOKEN_COUNT = 4;
const BOARD_SIZE = 52; // Number of main track cells
const PLAYER_COLORS = ['#ef4444', '#22c55e', '#3b82f6', '#f59e0b', '#ec4899', '#14b8a6']; // Red, Green, Blue, Yellow, Pink, Cyan
const PLAYER_NAMES = ['Red', 'Green', 'Blue', 'Yellow', 'Pink', 'Cyan'];

// Safe spots (marked by a star on a standard Ludo board)
const SAFE_SPOTS = [1, 9, 14, 22, 27, 35, 40, 48];
// Entry points for each player into the main track
const ENTRY_POINTS = [1, 14, 27, 40, 53, 66]; // 53=1+52, 66=14+52 - Handled modularly below
const HOME_ENTRY_POINTS = [52, 13, 26, 39]; // The cell right before the home path

// Final home path cells for each player (5 cells, plus the final destination)
const HOME_PATH_START = 53; // Arbitrary index to signify start of home path
const HOME_PATH_LENGTH = 6;

// --- HELPER FUNCTIONS FOR GAME LOGIC ---

/**
* Calculates the absolute position on the 52-cell track plus the home path (53-58).
* @param {number} startPos The starting cell number (0-51)
* @param {number} steps The number of steps to move
* @param {number} playerId The player ID (0-5)
* @returns {number} The new absolute position (1-52 or 53-58 for home path)
*/
const calculateNewPosition = (startPos, steps, playerId) => {
    if (startPos === 0) { // Token is in the base, needs a 6
        return steps === 6 ? ENTRY_POINTS[playerId] : 0;
    }

    let newPos = startPos + steps;

    // Check for movement into the home path
    const entry = HOME_ENTRY_POINTS[playerId];
    const trackEnd = BOARD_SIZE;

    // The cells where the token enters its home path
    const playerEntryOffset = entry > HOME_ENTRY_POINTS[0] ? entry - 1 : trackEnd - 1; // 51 for red, 12 for green, etc.

    if (startPos <= entry && newPos > entry) {
        // Red (0): 52 -> 53 (entry point is 1)
        if (playerId === 0 && tPos <= trackEnd && newPos > trackEnd) {
             return HOME_PATH_START + (newPos - trackEnd); // 53 is the first home cell
        }
        // Other Players: Token goes from 13 to 14, 26 to 27, etc.
        if (playerId !== 0 && startPos <= playerEntryOffset && newPos > playerEntryOffset) {
             // The number of steps that overshoot the final cell before home path
             const stepsIntoHome = newPos - playerEntryOffset;
             return HOME_PATH_START + stepsIntoHome;
        }
    }
   
    // Check for moving around the board (wrapping from 52 back to 1)
    if (newPos > BOARD_SIZE) {
        // Only wrap if it didn't already enter home path logic above (e.g., if entry is 14, newPos is 15, and startPos was 1)
        if (playerId !== 0 && startPos < entry) {
            newPos = (newPos - 1) % BOARD_SIZE + 1;
        } else if (playerId === 0 && startPos < trackEnd) {
             newPos = (newPos - 1) % BOARD_SIZE + 1;
        }
    }

    // Check if it's already on the home path (position 53 to 57)
    if (startPos >= HOME_PATH_START) {
        newPos = startPos + steps;
        if (newPos >= HOME_PATH_START + HOME_PATH_LENGTH) {
            return HOME_PATH_START + HOME_PATH_LENGTH; // Final home position (index 59 in data model, rendered as 'Home')
        }
        return newPos;
    }

    // Standard movement on the main track
    return (newPos - 1) % BOARD_SIZE + 1;
};


// --- AI LOGIC MODULE ---

const AI_DIFFICULTY_FACTORS = {
    easy: { capture: 0.3, home: 0.6, safety: 0.1, random: 0.8 },
    medium: { capture: 0.5, home: 0.8, safety: 0.3, random: 0.4 },
    hard: { capture: 0.9, home: 1.0, safety: 0.5, random: 0.1 },
};

/**
* AI Decision Function to choose the best move.
* @param {object} gameState The current game state.
* @param {number} playerId The current player ID.
* @param {number} diceRoll The result of the dice roll.
* @param {string} difficulty The AI difficulty level ('easy', 'medium', 'hard').
* @returns {number | null} The index of the token to move (0-3), or null if no move.
*/
const getBestMove = (gameState, playerId, diceRoll, difficulty = 'medium') => {
    const tokens = gameState.tokens[playerId];
    const opponentsTokens = gameState.tokens.filter((_, idx) => idx !== playerId).flat();
    const factors = AI_DIFFICULTY_FACTORS[difficulty] || AI_DIFFICULTY_FACTORS.medium;
   
    let bestMove = { score: -Infinity, tokenIndex: null };

    // 1. Generate all possible moves
    const possibleMoves = tokens.map((startPos, index) => {
        const newPos = calculateNewPosition(startPos, diceRoll, playerId);
        const canMove = startPos === 0 ? diceRoll === 6 : newPos !== startPos;
       
        // Cannot move into a cell already occupied by another token of the same color (blocking)
        const isBlocked = tokens.filter((p, i) => i !== index).includes(newPos) && newPos > 0 && newPos <= BOARD_SIZE;
       
        if (!canMove || isBlocked || newPos === startPos) return null;

        let score = 0;

        // --- Scoring Logic ---

        // 1a. Winning Move (Highest Priority)
        if (newPos === HOME_PATH_START + HOME_PATH_LENGTH) {
            score += 1000 * factors.home; // Huge score for winning
        }

        // 1b. Capturing Move
        const capturedToken = opponentsTokens.find(p => p.position === newPos && newPos > 0 && newPos <= BOARD_SIZE && !SAFE_SPOTS.includes(newPos));
        if (capturedToken) {
            score += 0 * factors.capture; // High score for capturing
        }

        // 1c. Getting out of Base (Next highest)
        if (startPos === 0 && newPos === ENTRY_POINTS[playerId]) {
            score += 200 * factors.home;
        }

        // 1d. Safety (Prioritize safe spots or home path progress)
        if (SAFE_SPOTS.includes(newPos) || newPos >= HOME_PATH_START) {
            score += 100 * factors.safety;
        }
       
        // 1e. General Progress (Small score for advancing)
        score += newPos; // The further the advance, the better

        // 1f. Danger Avoidance (Negative score for moving to a vulnerable spot)
        if (newPos > 0 && newPos <= BOARD_SIZE && !SAFE_SPOTS.includes(newPos)) {
            const isVulnerable = opponentsTokens.some(p => p.position > 0 && p.position <= BOARD_SIZE && calculateNewPosition(p.position, 6, p.player) === newPos);
            if (isVulnerable) {
                score -= 50 * (1 - factors.safety); // Penalize movement into immediate danger
            }
        }

        return { index, score, newPos };
    }).filter(move => move !== null);
   
    if (possibleMoves.length === 0) return null;

    // 2. Select the best move based on score, adding a random factor for non-hard difficulties
    possibleMoves.forEach(move => {
        // Add randomness based on difficulty
        let finalScore = move.score;
        if (difficulty !== 'hard') {
            finalScore += Math.random() * 200 * factors.random;
        }

        if (finalScore > bestMove.score) {
            bestMove = { score: finalScore, tokenIndex: move.index };
        }
    });

    return bestMove.tokenIndex;
};


// --- REACT COMPONENT ---

const LudoApp = () => {
    const [numPlayers, setNumPlayers] = useState(NUM_PLAYERS);
    const [players, setPlayers] = useState(PLAYER_NAMES.slice(0, NUM_PLAYERS).map((name, id) => ({
        id,
        name,
        color: PLAYER_COLORS[id],
        type: 'human', // 'human' or 'ai'
        difficulty: 'medium', // for 'ai'
    })));
    const [gameState, setGameState] = useState(null);
    const [dice, setDice] = useState(null);
    const [currentPlayer, setCurrentPlayer] = useState(0);
    const [message, setMessage] = useState('Start a new game!');
    const [selectedTokenIndex, setSelectedTokenIndex] = useState(null);
    const [isRolling, setIsRolling] = useState(false);
    const [isAiTurn, setIsAiTurn] = useState(false);
    const [aiDelay, setAiDelay] = useState(500); // milliseconds

    const initialGameState = useMemo(() => ({
        tokens: players.map(() => Array(TOKEN_COUNT).fill(0)), // 0 means in base
        isFinished: false,
        rank: [],
    }), [players]);

    const startGame = useCallback(() => {
        setGameState(initialGameState);
        setCurrentPlayer(0);
        setDice(null);
        setSelectedTokenIndex(null);
        setIsAiTurn(false);
        setMessage(`${players[0].name}'s turn. Roll the dice!`);
    }, [initialGameState, players]);

    useEffect(() => {
        startGame();
    }, [startGame, numPlayers]);

    // --- Core Game Logic ---

    const advanceTurn = useCallback((nextPlayer = null, rolledSix = false) => {
        if (gameState.isFinished) return;

        setDice(null);
        setSelectedTokenIndex(null);

        let nextPlayerIndex = nextPlayer !== null ? nextPlayer : currentPlayer;

        if (!rolledSix) {
            do {
                nextPlayerIndex = (nextPlayerIndex + 1) % numPlayers;
            } while (gameState.tokens[nextPlayerIndex].every(pos => pos === (HOME_PATH_START + HOME_PATH_LENGTH)));
        }
       
        setCurrentPlayer(nextPlayerIndex);
        setMessage(`${players[nextPlayerIndex].name}'s turn. Roll the dice!`);
    }, [currentPlayer, gameState, numPlayers, players]);

    const checkWinCondition = useCallback((newTokens) => {
        const newRank = [...gameState.rank];
        let allFinished = true;

        newTokens.forEach((tokens, playerId) => {
            const isPlayerFinished = tokens.every(pos => pos === (HOME_PATH_START + HOME_PATH_LENGTH));
            if (isPlayerFinished && !newRank.includes(playerId)) {
                newRank.push(playerId);
            }
        });

        const numActivePlayers = players.filter((_, id) => !newRank.includes(id)).length;
        if (numActivePlayers <= 1) { // Game ends when only one player is left, or all are finished
            setGameState(prev => ({
                ...prev,
                isFinished: true,
                rank: newRank,
            }));
            setMessage(`Game Over! Winner: ${players[newRank[0]].name}`);
            return true;
        }

        setGameState(prev => ({ ...prev, rank: newRank }));
        return false;
    }, [gameState.rank, players]);
   
    const rollDice = useCallback(() => {
        if (gameState.isFinished || dice !== null || isRolling) return;
       
        setIsRolling(true);
        setMessage('Rolling...');

        setTimeout(() => {
            const roll = Math.floor(Math.random() * 6) + 1;
            setDice(roll);
            setIsRolling(false);
            setMessage(`${players[currentPlayer].name} rolled a ${roll}. Select a token.`);
        }, 500); // Dice animation delay
    }, [gameState.isFinished, dice, isRolling, players, currentPlayer]);

    const handleTokenMove = useCallback((tokenIndex) => {
        if (gameState.isFinished || dice === null || isRolling || isAiTurn) return;
       
        const currentTokens = gameState.tokens[currentPlayer];
        const startPos = currentTokens[tokenIndex];
        const newPos = calculateNewPosition(startPos, dice, currentPlayer);

        // 1. Check if the move is legal (covers "must roll 6 to exit base")
        const isLegal = startPos === 0 ? dice === 6 : newPos !== startPos && newPos !== 0;
       
        // Cannot move into a cell already occupied by another token of the same color (blocking)
        const isBlocked = currentTokens.filter((_, i) => i !== tokenIndex).includes(newPos) && newPos > 0 && newPos <= BOARD_SIZE;

        if (!isLegal || isBlocked) {
            setMessage('Illegal move! Select another token or pass turn if no valid moves remain.');
            setSelectedTokenIndex(null);
            return;
        }

        // 2. Deep copy and apply the move
        const newTokens = gameState.tokens.map((arr, i) => i === currentPlayer ? arr.map((pos, j) => j === tokenIndex ? newPos : pos) : arr);

        let didCapture = false;

        // 3. Check for Capturing (only on main track, not safe spots)
        if (newPos > 0 && newPos <= BOARD_SIZE && !SAFE_SPOTS.includes(newPos)) {
            for (let i = 0; i < numPlayers; i++) {
                if (i !== currentPlayer) {
                    newTokens[i] = newTokens[i].map(oppPos => {
                        if (oppPos === newPos) {
                            didCapture = true;
                            setMessage(`${players[currentPlayer].name} captured ${players[i].name}'s token!`);
                            return 0; // Send opponent's token back to base
                        }
                        return oppPos;
                    });
                }
            }
        }

        // 4. Update Game State
        setGameState(prev => ({ ...prev, tokens: newTokens }));
       
        // 5. Check for Win/Advance Turn
        if (checkWinCondition(newTokens)) return;
       
        // 6. Advance Turn Logic
        if (dice === 6 || didCapture || newPos === HOME_PATH_START + HOME_PATH_LENGTH) {
            // Player gets another roll if they rolled a 6, captured a token, or reached home
            setDice(null);
            setMessage(`${players[currentPlayer].name} gets another roll!`);
        } else {
            advanceTurn(null, false);
        }
       
    }, [currentPlayer, dice, gameState.isFinished, gameState.tokens, isRolling, isAiTurn, numPlayers, players, advanceTurn, checkWinCondition]);

    // --- AI Turn Handler ---
    useEffect(() => {
        if (gameState && !gameState.isFinished && players[currentPlayer].type === 'ai' && dice !== null && !isRolling && !isAiTurn) {
            setIsAiTurn(true);
            setMessage(`AI (${players[currentPlayer].name}) is thinking...`);

            setTimeout(() => {
                const difficulty = players[currentPlayer].difficulty;
                const tokenIndexToMove = getBestMove(gameState, currentPlayer, dice, difficulty);

                if (tokenIndexToMove !== null) {
                    // Execute the move through the human move handler
                    handleTokenMove(tokenIndexToMove);
                } else {
                    // No valid move, advance turn
                    setMessage(`AI (${players[currentPlayer].name}) has no valid moves.`);
                    advanceTurn(null, false);
                }
               
                setIsAiTurn(false);
            }, aiDelay);
        }
    }, [gameState, currentPlayer, players, dice, isRolling, isAiTurn, handleTokenMove, advanceTurn, aiDelay]);

    // Handles AI rolling the dice automatically
    useEffect(() => {
        if (gameState && !gameState.isFinished && players[currentPlayer].type === 'ai' && dice === null && !isRolling && !isAiTurn) {
            setIsAiTurn(true);
            setTimeout(rollDice, aiDelay);
        }
    }, [gameState, players, currentPlayer, dice, isRolling, isAiTurn, rollDice, aiDelay]);

    // --- UI RENDERING HELPERS ---

    const renderBoardCell = (index) => {
        const isSafe = SAFE_SPOTS.includes(index);
        const isEntry = ENTRY_POINTS.slice(0, numPlayers).includes(index);
       
        let cellClass = 'w-8 h-8 md:w-10 md:h-10 border border-gray-300 flex items-center justify-center text-xs relative';
       
        if (isSafe || isEntry) {
            cellClass += ' bg-gray-200 border-2 border-yellow-500';
            if (isSafe) {
                 cellClass += ' shadow-inner';
            }
        } else {
            cellClass += ' bg-white';
        }

        const tokensInCell = gameState.tokens.flatMap((tokens, pId) =>
            tokens.map((pos, tIdx) => ({ pId, tIdx, pos }))
        ).filter(token => token.pos === index);

        return (
            <div key={index} className={cellClass}>
                {tokensInCell.map(({ pId, tIdx }) => (
                    <Token
                        key={`${pId}-${tIdx}`}
                        playerId={pId}
                        tokenIndex={tIdx}
                        isCurrentPlayer={pId === currentPlayer && dice !== null && players[currentPlayer].type === 'human' && !isAiTurn}
                        onMove={handleTokenMove}
                        isSelected={selectedTokenIndex === tIdx && pId === currentPlayer}
                    />
                ))}
            </div>
        );
    };

    const renderBaseCell = (playerId, tokenIndex) => {
        const basePos = 0;
       
        const tokensInBase = gameState.tokens[playerId].flatMap((pos, tIdx) =>
            pos === basePos ? [{ tIdx }] : []
        );

        const isPlayerTurn = playerId === currentPlayer && players[currentPlayer].type === 'human' && dice !== null && !isAiTurn;
       
        return (
            <div
                key={playerId}
                style={{ backgroundColor: PLAYER_COLORS[playerId] + '33' }}
                className="w-full h-full p-2 grid grid-cols-2 gap-1 border-4 rounded-lg shadow-inner"
            >
                {Array(TOKEN_COUNT).fill(0).map((_, tIdx) => {
                    const isInBase = gameState.tokens[playerId][tIdx] === 0;
                   
                    return (
                        <div key={tIdx} className="w-full h-full flex items-center justify-center">
                            {isInBase && (
                                <Token
                                    playerId={playerId}
                                    tokenIndex={tIdx}
                                    isCurrentPlayer={isPlayerTurn && dice === 6}
                                    onMove={handleTokenMove}
                                    isSelected={selectedTokenIndex === tIdx && isPlayerTurn}
                                />
                            )}
                        </div>
                    );
                })}
            </div>
        );
    };

    const renderHomePath = (playerId) => {
        return Array(HOME_PATH_LENGTH - 1).fill(0).map((_, i) => {
            const pos = HOME_PATH_START + i + 1; // 53 to 57
           
            const tokensInCell = gameState.tokens[playerId].flatMap((pos, tIdx) =>
                pos === HOME_PATH_START + i + 1 ? [{ tIdx }] : []
            );

            return (
                <div
                    key={pos}
                    style={{ backgroundColor: PLAYER_COLORS[playerId] + '33' }}
                    className="w-8 h-8 md:w-10 md:h-10 border border-gray-300 flex items-center justify-center relative"
                >
                    {tokensInCell.map(({ tIdx }) => (
                        <Token key={tIdx} playerId={playerId} tokenIndex={tIdx} isHomePath={true} />
                    ))}
                </div>
            );
        });
    };

    const renderHome = (playerId) => {
        const finalPos = HOME_PATH_START + HOME_PATH_LENGTH; // 58
       
        const tokensInHome = gameState.tokens[playerId].flatMap((pos, tIdx) =>
            pos === finalPos ? [{ tIdx }] : []
        );

        return (
            <div
                key={'home' + playerId}
                style={{ backgroundColor: PLAYER_COLORS[playerId] }}
                className="w-full h-full rounded-full flex items-center justify-center relative shadow-lg"
            >
                <Home className="w-1/2 h-1/2 text-white" />
                <div className="absolute grid grid-cols-2 gap-1 p-1">
                    {tokensInHome.map(({ tIdx }) => (
                        <Token key={tIdx} playerId={playerId} tokenIndex={tIdx} isHome={true} />
                    ))}
                </div>
            </div>
        );
    };


    const Token = ({ playerId, tokenIndex, isCurrentPlayer, onMove, isSelected, isHomePath, isHome }) => {
        const handleClick = () => {
            if (isCurrentPlayer) {
                if (isSelected) {
                    onMove(tokenIndex);
                } else {
                    setSelectedTokenIndex(tokenIndex);
                }
            }
        };

        const sizeClass = isHomePath || isHome ? 'w-4 h-4 md:w-5 md:h-5' : 'w-6 h-6 md:w-7 md:h-7';
       
        let tokenClasses = `${sizeClass} rounded-full absolute cursor-pointer transition-all duration-100 ease-out shadow-md border-2 border-white`;
       
        if (isCurrentPlayer && !isHomePath && !isHome) {
            tokenClasses += ' hover:scale-110 ring-2 ring-offset-2 animate-pulse';
            if (isSelected) {
                tokenClasses += ' ring-yellow-400 scale-110 shadow-xl';
            } else {
                tokenClasses += ' ring-white';
            }
        }

        if (isHome) {
            tokenClasses = 'w-4 h-4 rounded-full'; // Smaller size in home
        }

        return (
            <div
                style={{ backgroundColor: PLAYER_COLORS[playerId] }}
                className={tokenClasses}
                onClick={handleClick}
            >
                {/* Optional: Add token number for debugging */}
                {/* <span className="text-[8px] text-white font-bold">{tokenIndex + 1}</span> */}
            </div>
        );
    };

    // --- BOARD LAYOUT DATA ---
    // A simplified layout grid based on Ludo structure (15x15)
    // C=Cell, B=Base, H=Home Path, D=Final Home Destination

    const BOARD_GRD = [
        // 0  1  2  3  4  5  6   7   8  9 10 11 12 13 14
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'C', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 0
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 1
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 2
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 3
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 4
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 5
        ['C', 'C', 'C', 'C', 'C', 'C', 'H', 'H', 'H', 'C', 'C', 'C', 'C', 'C', 'C'], // 6
        ['C', 'H', 'H', 'H', 'H', 'H', 'D', 'D', 'D', 'H', 'H', 'H', 'H', 'H', 'C'], // 7
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'H', 'C', 'C', 'C', 'C', 'C', 'C', 'C'], // 8
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 9
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 10
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 11
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 12
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'H', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 13
        ['B', 'B', 'B', 'B', 'B', 'B', 'C', 'C', 'C', 'B', 'B', 'B', 'B', 'B', 'B'], // 14
    ];

    // Mappings from (row, col) to main track index (1-52)
    const CELL_MAPPING = {
        // Red Path (Right to Bottom, 1-13)
        '6,1': 1, '6,2': 2, '6,3': 3, '6,4': 4, '6,5': 5,
        '5,6': 6, '4,6': 7, '3,6': 8, '2,6': 9, '1,6': 10, '0,6': 11,
        '0,7': 12, '0,8': 13,
        // Green Path (Top to Left, 14-26)
        '1,8': 14, '2,8': 15, '3,8': 16, '4,8': 17, '5,8': 18,
        '6,9': 19, '6,10': 20, '6,11': 21, '6,12': 22, '6,13': 23, '6,14': 24,
        '7,14': 25, '8,14': 26,
        // Blue Path (Left to Top, 27-39)
        '8,13': 27, '8,12': 28, '8,11': 29, '8,10': 30, '8,9': 31,
        '9,8': 32, '10,8': 33, '11,8': 34, '12,8': 35, '13,8': 36, '14,8': 37,
        '14,7': 38, '14,6': 39,
        // Yellow Path (Bottom to Right, 40-52)
        '13,6': 40, '12,6': 41, '11,6': 42, '10,6': 43, '9,6': 44,
        '8,5': 45, '8,4': 46, '8,3': 47, '8,2': 48, '8,1': 49, '8,0': 50,
        '7,0': 51, '6,0': 52,
       
        // Home Paths (53 to 57)
        // Red (0) - Right side of center
        '7,1': 53, '7,2': 54, '7,3': 55, '7,4': 56, '7,5': 57,
        // Green (1) - Top side of center
        '1,7': 53, '2,7': 54, '3,7': 55, '4,7': 56, '5,7': 57,
        // Blue (2) - Left side of center
        '7,9': 53, '7,10': 54, '7,11': 55, '7,12': 56, '7,13': 57,
        // Yellow (3) - Bottom side of center
        '13,7': 53, '12,7': 54, '11,7': 55, '10,7': 56, '9,7': 57,
    };
   
    // Player Base Mappings
    const BASE_MAPPING = {
        '0,0': 0, '0,14': 1, '14,14': 2, '14,0': 3,
        // Supports up to 6 players if logic is expanded
    };


    const renderGridItem = (row, col) => {
        const type = BOARD_GRID[row][col];
        const key = `${row},${col}`;

        if (!gameState) return <div key={key} className="w-8 h-8 md:w-10 md:h-10 bg-gray-50"></div>;

        // Main Track Cells (1-52)
        if (type === 'C') {
            const index = CELL_MAPPING[key];
            return renderBoardCell(index);
        }

        // Base Areas (Player 0, 1, 2, 3)
        if (type === 'B') {
            const playerId = BASE_MAPPING[key];
            if (playerId !== undefined && playerId < numPlayers) {
                return renderBaseCell(playerId);
            }
            return <div key={key} className="w-8 h-8 md:w-10 md:h-10 bg-gray-50"></div>;
        }

        // Home Path Cells (H)
        if (type === 'H') {
            // Determine which player's home path it is
            let playerId = -1;
            let pathIndex = -1; // 1 to 5
           
            // Red Home Path (0) - Vertical in row 6-1
            if (col === 7 && row < 6) { playerId = 0; pathIndex = 6 - row; }
            // Green Home Path (1) - Horizontal in col 9-13
            else if (row === 7 && col > 8) { playerId = 1; pathIndex = col - 8; }
            // Blue Home Path (2) - Vertical in row 8-13
            else if (col === 7 && row > 8) { playerId = 2; pathIndex = row - 8; }
            // Yellow Home Path (3) - Horizontal in col 5-1
            else if (row === 7 && col < 6) { playerId = 3; pathIndex = 6 - col; }

            if (playerId !== -1 && playerId < numPlayers) {
                const pos = HOME_PATH_START + pathIndex;
                const tokensInCell = gameState.tokens[playerId].flatMap((p, tIdx) => p === pos ? [{ tIdx }] : []);
               
                return (
                    <div
                        key={key}
                        style={{ backgroundColor: PLAYER_COLORS[playerId] + '33' }}
                        className="w-8 h-8 md:w-10 md:h-10 border border-gray-300 flex items-center justify-center relative shadow-inner"
                    >
                        {tokensInCell.map(({ tIdx }) => (
                            <Token key={tIdx} playerId={playerId} tokenIndex={tIdx} isHomePath={true} />
                        ))}
                    </div>
                );
            }
            return <div key={key} className="w-8 h-8 md:w-10 md:h-10 bg-gray-50"></div>; // Placeholder for unused H cells
        }

        // Center Destination (D)
        if (type === 'D') {
            // The 4 center cells are the final home for each player
            if (row === 7 && col === 7) return renderHome(0); // Red (Top)
            if (row === 7 && col === 7) return renderHome(1); // Green (Right) - simplified center rendering
            if (row === 7 && col === 7) return renderHome(2); // Blue (Bottom)
            if (row === 7 && col === 7) return renderHome(3); // Yellow (Left)
           
            // Central intersection (simplified rendering)
            return (
                <div key={key} className="w-full h-full p-1 flex flex-wrap justify-center items-center bg-gray-100 shadow-xl border-4 border-gray-400">
                    <div className="text-xl font-bold text-gray-700 select-none">LUDO</div>
                    {/* Render the 4 final home tokens */}
                    {players.slice(0, numPlayers).map(p => (
                         <div key={p.id} className="w-1/2 h-1/2 flex items-center justify-center">
                            {renderHome(p.id)}
                         </div>
                    ))}
                </div>
            );
        }

        // Fallback for unused cells
        return <div key={key} className="w-8 h-8 md:w-10 md:h-10 bg-gray-50"></div>;
    };
   
    // --- UI COMPONENTS ---

    const PlayerSettings = () => {
        const handlePlayerCountChange = (e) => {
            const newCount = parseInt(e.target.value);
            setNumPlayers(newCount);
            setPlayers(prev => {
                const newPlayers = PLAYER_NAMES.slice(0, newCount).map((name, id) => ({
                    id,
                    name,
                    color: PLAYER_COLORS[id],
                    type: prev[id]?.type || 'human',
                    difficulty: prev[id]?.difficulty || 'medium',
                }));
                return newPlayers;
            });
        };

        const handleTypeChange = (id, newType) => {
            setPlayers(prev => prev.map(p => p.id === id ? { ...p, type: newType } : p));
        };

        const handleDifficultyChange = (id, newDifficulty) => {
            setPlayers(prev => prev.map(p => p.id === id ? { ...p, difficulty: newDifficulty } : p));
        };

        return (
            <div className="p-4 bg-gray-50 rounded-lg shadow-inner">
                <h3 className="text-lg font-bold mb-3 text-gray-700">Setup ({numPlayers} Players)</h3>
               
                <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-600 mb-1">Number of Players:</label>
                    <select
                        value={numPlayers}
                        onChange={handlePlayerCountChange}
                        className="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"
                    >
                        {[2, 3, 4, 5, 6].map(n => <option key={n} value={n}>{n} Players</option>)}
                    </select>
                </div>

                <div className="space-y-3 max-h-48 overflow-y-auto pr-2">
                    {players.map(player => (
                        <div key={player.id} className="flex flex-col p-2 rounded-md shadow-sm border" style={{ borderColor: player.color }}>
                            <div className="flex justify-between items-center mb-1">
                                <span className="font-semibold" style={{ color: player.color }}>{player.name} (P{player.id + 1})</span>
                                <span className="text-xs text-gray-500">
                                    {gameState?.rank.includes(player.id) && <span className="text-green-600 font-bold">Finished: #{gameState.rank.indexOf(player.id) + 1}</span>}
                                </span>
                            </div>
                           
                            <div className="flex space-x-2">
                                <select
                                    value={player.type}
                                    onChange={(e) => handleTypeChange(player.id, e.target.value)}
                                    className="p-1 text-sm border border-gray-300 rounded-md flex-1"
                                    disabled={gameState?.rank.includes(player.id)}
                                >
                                    <option value="human">Human</option>
                                    <option value="ai">AI Bot</option>
                                </select>
                                {player.type === 'ai' && (
                                    <select
                                        value={player.difficulty}
                                        onChange={(e) => handleDifficultyChange(player.id, e.target.value)}
                                        className="p-1 text-sm border border-gray-300 rounded-md flex-1"
                                        disabled={gameState?.rank.includes(player.id)}
                                    >
                                        <option value="easy">Easy</option>
                                        <option value="medium">Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                )}
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        );
    };

    const GameControls = () => {
        const isCurrentPlayerAi = players[currentPlayer]?.type === 'ai';
        const isDiceRolled = dice !== null;
        const canRoll = !gameState.isFinished && dice === null && !isRolling && !isAiTurn && !isCurrentPlayerAi;

        // Determine if the human player has any possible moves
        let hasValidMove = false;
        if (isDiceRolled && !isCurrentPlayerAi) {
            const currentTokens = gameState.tokens[currentPlayer];
            for (let i = 0; i < TOKEN_COUNT; i++) {
                const startPos = currentTokens[i];
                const newPos = calculateNewPosition(startPos, dice, currentPlayer);
                const isLegal = startPos === 0 ? dice === 6 : newPos !== startPos && newPos !== 0;
               
                // Cannot move into a cell already occupied by another token of the same color (blocking)
                const isBlocked = currentTokens.filter((_, j) => j !== i).includes(newPos) && newPos > 0 && newPos <= BOARD_SIZE;

                if (isLegal && !isBlocked) {
                    hasValidMove = true;
                    break;
                }
            }
        }
       
        const canPass = !isAiTurn && isDiceRolled && !hasValidMove && !isCurrentPlayerAi;
       
        return (
            <div className="p-4 bg-white rounded-lg shadow-xl border-t-4 border-blue-500">
                <div className="flex items-center justify-between mb-3">
                    <h4 className="text-lg font-bold">Current Turn:</h4>
                    <span
                        className="p-2 rounded-full font-bold text-white shadow-md"
                        style={{ backgroundColor: players[currentPlayer]?.color || 'gray' }}
                    >
                        {players[currentPlayer]?.name}
                    </span>
                </div>

                <div className="flex items-center justify-center space-x-4 mb-4">
                    <div
                        className={`w-16 h-16 flex items-center justify-center text-4xl font-extrabold rounded-xl shadow-inner border-4 ${dice !== null ? 'bg-yellow-300 border-yellow-500' : 'bg-gray-200 border-gray-400'}`}
                    >
                        {isRolling ? <RotateCcw className="w-8 h-8 animate-spin text-gray-600" /> : dice || <Dice6 className="w-8 h-8 text-gray-600" />}
                    </div>
                   
                    <button
                        onClick={rollDice}
                        disabled={!canRoll}
                        className={`p-3 rounded-xl font-bold text-white shadow-lg transition-all duration-200 ${canRoll ? 'bg-green-600 hover:bg-green-700 active:scale-95' : 'bg-gray-400 cursor-not-allowed'}`}
                    >
                        {isRolling ? 'Rolling...' : 'Roll Dice'}
                    </button>
                </div>
               
                <div className="text-center mb-4 p-2 rounded-lg bg-blue-100 text-blue-800 font-medium">
                    {message}
                </div>

                {canPass && (
                    <button
                        onClick={() => advanceTurn(null, false)}
                        className="w-full p-3 rounded-xl font-bold text-white bg-red-500 hover:bg-red-600 active:scale-95 transition-all duration-200 shadow-md"
                    >
                        No Valid Move - Pass Turn
                    </button>
                )}

                <button
                    onClick={startGame}
                    className="w-full mt-3 p-3 rounded-xl font-bold text-gray-700 bg-yellow-400 hover:bg-yellow-500 active:scale-95 transition-all duration-200 shadow-md flex items-center justify-center space-x-2"
                >
                    <RefreshCcw className="w-5 h-5" />
                    <span>Restart Game</span>
                </button>
            </div>
        );
    };


    if (!gameState) return <div className="text-center p-10">Loading Game...</div>;

    // --- MAIN RENDER ---
    return (
        <div className="min-h-screen bg-gray-100 p-4 flex flex-col items-center justify-center md:flex-row md:space-x-8">
           
            {/* Control Panel (Mobile first: Top/Left) */}
            <div className="w-full md:w-1/3 space-y-4 mb-4 md:mb-0">
                <GameControls />
                <PlayerSettings />
            </div>

            {/* Ludo Board */}
            <div className="w-full max-w-md md:w-2/3 aspect-square bg-white shadow-2xl rounded-xl p-2 md:p-4">
                <div
                    className="grid grid-cols-15 grid-rows-15 w-full h-full border-4 border-gray-700 rounded-xl overflow-hidden"
                    style={{
                        gridTemplateColumns: 'repeat(15, minmax(0, 1fr))',
                        gridTemplateRows: 'repeat(15, minmax(0, 1fr))',
                    }}
                >
                    {BOARD_GRID.flatMap((rowArr, row) =>
                        rowArr.map((_, col) => renderGridItem(row, col))
                    )}
                </div>
            </div>
        </div>
    );
};
